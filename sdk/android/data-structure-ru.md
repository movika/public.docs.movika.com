---
title: Структура данных
description: Описание структур данных в SDK и Manifest
keywords: Структура данных, Manifest, Манифест
sort: 5
---

# Структура Manifest в формате json.
manifest.json - это файл, который принимается на вход интерактивным плеером для воспроизведения контента

Структура manifest.json:

    {
        "metadata": { ... },
        "chapters": [ ... ],
    }

- metadata - объект, который содержит общие сведения о манифесте. Далее такой объект будем называть Metadata
- chapters - список глав интерактивного видео. Далее такие главы будем называть Chapter. Подробнее о том, что такое 
глава и как выглядит её структура, будет разобрано в разделе "Структура Chapter"

## Структура Metadata
Пример объекта metadata:

    "metadata": {
        "id": "31ab429c-1594-4611-8132-8c8f61bece50",
        "version": "3.1",
        "build": 0,
        "created": "2019-08-24T14:15:22Z",
        "updated": "2019-08-24T14:15:22Z",
        "media": "media.json",
        "initChapterId": "f60cc928-77a1-4763-9138-5c7055c9484c"
    }

- id - уникальный идентификатор манифеста. Обычно идентификатором манифеста является UUID
- version - версия формата манифеста
- build - номер сборки текущего манифеста. Другими словами, версионирование в рамках одного манифеста
- created - опциональное поле. Содержит дату создания манифеста
- updated - опциональное поле. Содержит дату последнего обновления манифеста
- media - ссылка на media.json файл. Представляет собой файл с описанием ресурсов (ссылки на видео, картинки и т.п.). 
Может быть как абсолютным путём, так и относительным. Например, если данное поле содержит относительный путь 
"some.json", а манифест располагается по адресу https://example.com/project/1/manifest.json, то media.json файл будет 
располагаться по адресу https://example.com/project/1/some.json
- initChapterId - содержит уникальный идентификатор (UUID) стартовой главы. Если данное поле отсутствует, то стартовой 
главой принимается первая глава в списке глав манифеста

### Структура media.json
Данный файл описывает ресурсы необходимые для воспроизведения манифеста.  
Пример файла media.json:

    {
        "videos": [
            {
              "id": "faed420e-9a33-4d73-ab3b-0f8adfd054b7",
              "duration": 25888,
              "variants": [
                {
                    "type": "hls",
                    "url": "https://example.com/my/awesome/project/1.mp4",
                    "size": 90012388,
                    "standard": "240p",
                    "resolution": "1920x1080",
                    "bitrate": 604106,
                    "cover": "https://example.com/my/awesome/project/cover.png",
                    "preview": "https://example.com/my/awesome/project/preview.webp"
                }
              ]
            }
        ]
    }

- videos - содержит список видео. Объект из такого списка будем называть Video

#### Структура Video

- id - уникальный идентификатор видео. Обычно выражен в формате UUID. Как правило, главы (chapters) ссылаются на id 
видео
- duration - опциональное поле. Содержит длительность видео в миллисекундах
- variants - содержит список вариантов данного видео (разные форматы и качества). Далее такой вариант будем называть 
VideoVariant

#### Структура VideoVariant
- type - формат (протокол, стандарт) видео. На данный момент поддерживаются следующие типы: hls, mp4
- url - URL файла видео. Может быть относительным расположения media.json
- size - опциональное поле. Содержит размер видео файла в байтах
- standard - опциональное поле. Содержит стандарт (качество) видео. Если поле отсутствует и type = hls, то вероятнее 
всего данный вариант ссылается на главный hls плейлист. Пример стандартов: 240p, 360p, 480p, 720p, 1080p
- resolution - опциональное поле. Содержит разрешение видео
- bitrate - опциональное поле. Содержит значение bitrate видео в бит/сек
- cover - опциональное поле. Содержит URL обложки видео файла
- preview - опциональное поле. Содержит URL анимированного превью видео

## Структура Chapter
Глава:
1. Сущность, содержащая описание контейнеров (интерактивов) для конкретного видео.
2. Неотъемлемая часть интерактивного видеоконтента, которая предаставляет из себя связку из конкретного видео, 
контейнеров (интерактивов) и веток. Может ссылать только на видео и не содержать веток и ссылки на видео, если глава
является финалом интерактивного видео

Пример объекта Chapter:
    
    {
        "id": "f60cc928-77a1-4763-9138-5c7055c9484c",
        "videoId": "5e428d1d-cac1-4ba1-bf69-01a8dcfa0e63",
        "containers": [ ... ],
        "branches": [ ... ]
    }

- id - уникальный идентификатор главы
- videoId - уникальный идентификатор видео, описание которого находится в media.json файле
- containers - список контейнеров (составных контролов, интерактивов) в данной главе, которые описывают интерактивные 
объекты и выбор ветки при определенных условиях. Список пуст, если глава является финалом интерактивного видео. Далее 
такой объект списка будем называть Container
- branches - содержит объекты Branch. Branch являются ветки исходящие из данной главы. Другими словами, Branch связывает
текущую главу с набором глав в которые можно попасть из данной главы. Список пуст, если глава является финальной

### Структура Container
Пример объекта Container:

    {
        "id": "497f6eca-6276-4993-bfeb-53cbbbba6f08",
        "startTime": 5000,
        "fallbackStrategy": "await",
        "controls": [ ... ],
        "layout": {
            "type": "Relative"
        },
        "type": "Choice",
        "containerAction": { ... }
    }

- id - содержит уникальный идентификатор контейнера
- startTime - время появления контейнера. Задается в миллисекундах. Является относительным к видео на которое ссылается 
текущая глава
- endTime - опциональное поле. Время конца жизни контейнера относительно текущей главы. Задается в миллисекундах. Если 
содержит значение null или поле отсутствует, то следует считать концом жизни контейнера временной конец главы. При 
достижении временного конца контейнера происходит действие согласно полю fallbackStrategy
- fallbackStrategy - опциональное поле. Стратегия выбора следующей ветки. Применяется, если пользователь до временного 
конца контейнера не совершил выбор, определяющий следующую главу, или не произвёл необходимых действий, при которых 
определяется следующая глава. Стратегией выбора считается await, если данное поле отсутствует или равно _null_. Данное 
поле может принимать следующие значения:
  - await - ничего не делать. Другими словами, ожидать пока пользователь не совершит выбор. В этот момент 
воспроизведение видео ставиться на паузу на месте временного конца контейнера
  - min - выбрать ветку с наименьшим значением поля weight
  - max - выбрать ветку с наибольшим значением поля weight
  - random - выбрать ветку случайно с учетом поля weight. Чем больше значение weight, тем выше вероятность выбора ветки
  - weightlessRandom - выбрать ветку случайно, игнорируя значения полей weight
  - default - выбрать первую ветку у которой имеется поле isDefault со значением true
- controls - список контролов. Под контролами подразумевается такие элементы как кнопки, области нажатия, текстовое поле 
ввода и т.п. Далее такие объекты будем называть Control
- layout - описание общей схемы (принципа) расположения контролов в контейнере. Рассмотрим на примере layout с 
type = Relative. Если в контейнере задан такой layout, то все контролы будут расположены относительно размеров видео. 
Пример, если ширина видео 1920, а в блоке layoutParams у контрола поле **x** равняется 0.1, то координата **x** при 
отрисовке будет равняться 0.1 * 1920 = 192. Координата **y** будет высчитываться уже относительно высоты видео. Таким 
же образом будут высчитываться размеры контрола. Поддерживаемые типы SDK по умолчанию: Relative.
- type - тип контейнера. Данное поле может быть использовано для создания пользовательских контейнеров. Поддерживаемые
типы SDK по умолчанию: Choice
- containerAction - опциональное поле. Содержит описание действия, которое необходимо выполнить (объект типа Action). 
Как правило, действие привязывается к некоторому событию контрола. Так же, данное действие может быть выполнено в 
любое время на усмотрение контейнера
- props - содержит объект с необходимыми параметрами для конкретного значения type

#### Структура Action
Специальный объект, которое описывает некоторое действие для взаимодействия с игровой логикой. Рассмотрим общий вид
Action:  

    {
        "type": "...",
        "args": { ... }
    }

- type - тип действия
- args - произвольный объект. Содержит набор необходимых параметров для конкретного типа Action

В SDK существуют следующие типы Action: setNextBranch, openURI. Рассмотрим каждый из них

Структура Action типа setNextBranch:

    {
        "type": "setNextBranch",
        "args": {
            "branchId": "dd80d4fa-3be5-4467-89d0-d90819ec858a",
            "shouldOpenNow": false
        }
    }

Action типа setNextBranch при вызове определяет ветку, по которой должен свершиться переход на следующую главу. Является 
основным Action в SDK.
Рассмотрим аргументы (args) данного Action:  
- branchId - содержит уникальный идентификатор ветки, по которой будет совершен переход
- shouldOpenNow - содержит значение, которое определяет, когда нужно совершить переход. При значении **true** переход
будет осуществлен незамедлительно, при значении **false** переход будет осуществлен, когда воспроизведение текущей главы
будет закончено. Примечание: в ситуации, когда shouldOpenNow содержит значение **false**, другой вызов setNextBranch в 
этой главе может переназначить установленную ветку

Структура Action типа openURI:

    {
        "type": "openURI",
        "args": {
            "uri": "https://example.uri",
        }
    }
Рассмотрим аргументы (args) данного Action:
- uri - ссылка, которая должна быть открыта при вызове данного Action


#### Структура Control
Общая структура Control на примере Button:

    {
        "id": "2cc1ab8b-5965-4503-b730-1fb1badb2b05",
        "type": "Button",
        "layoutParams": {
            "x": "0.2",
            "y": "0.55",
            "width": "0.3",
            "height": "0.12"
        },
        "props": { ... },
        "events": [
            {
                "type": "onClick",
                "action": {
                    "type": "setNextBranch",
                    "args": {
                        "branchId": "dd80d4fa-3be5-4467-89d0-d90819ec858a",
                        "shouldOpenNow": false
                    }
                }
            }
        ]
    }

- id - содержит уникальный идентификатор контрола
- type - содержит тип Control. По умолчанию поддерживаемые типы: Button, Area
- layoutParams - содержит описания расположения контрола и его размеров в соответствии с типом layout в контейнере. В 
данном случае приведен пример layoutParams для layout типа Relative
- props - содержит уникальные для каждого типа контрола дополнительные параметры
- events - содержит список событий контрола. Элемент такого списка представляет собой связку между типом события и 
Action. Каждый контрол сам ответственен за обработку событий. Набор типов возможных событий для каждого типа контрола 
может быть разным. Например Control типа Button поддерживает событие одного типа - onClick

#### Пример структуры props для контрола типа Button:
    "props": { 
        "text": {
            "value": "Some text",
            "gravityHorizontal": "center",
            "gravityVertical": "center",
            "color": "#FFFFFF",
            "alpha": 0.85,
            "size": 0.5
        },
        "background": {
            "type": "color",
            "color": "#008080",
            "alpha": 0.85
        },
        "shape": {
            "type": "rectangle",
            "roundCorners": 0.2,
            "border": {
                "width": 0.01,
                "color": "#000000",
                "alpha": 1
            }
        }
    }

# Структура данных в SDK
В данном разделе описаны структуры, которые могут понадобиться при создании пользовательских контейнеров и контролов

## Класс Container

Описание класса Container:

    data class Container constructor(
        val id: String,
        val parentChapterId: String,
        val startTime: Long,
        val endTime: Long?,
        val layout: Layout,
        val fallbackStrategy: FallbackStrategy,
        val type: String,
        val controls: List<Control>,
        val containerAction: Action?,
        val props: String?
    )

Как видно на примере, данный класс почти полностью повторяет структуру контейнера в manifest.json, но есть
небольшие различия
- parentChapterId - уникальной идентификатор главы, к которому привязан контейнер
- props - представлен не в виде конкретного объекта, а в виде строки. Каждый контейнер должен сам по своему
усмотрению парсить объект props из json под свою подходящую структуру данных. Данный подход позволяет без особого труда
внедрять новые пользовательские контейнеры

## Класс Control
Описание класса Control:

    data class Control(
        val id: String,
        val type: String,
        val layoutParams: LayoutParams?,
        val events: List<Event>,
        val props: String?
    )

Как и в случае с Container, у класса Control есть небольшие различия с его представлением в manifest.json
- props - представлен не в виде конкретного объекта, а в виде строки. Каждый контрол должен сам по своему
  усмотрению парсить объект props из json под свою подходящую структуру данных. Данный подход позволяет без особого труда
  внедрять новые пользовательские контролы