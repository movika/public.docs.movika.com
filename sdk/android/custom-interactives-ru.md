---
title: Пользовательские интерактивы
description: Создание пользовательских интерактивов
keywords: Пользовательские интерактивы, кастомные интерактивы, пользовательские контейнеры, пользовательские контролы, кастомные контейнеры, кастомные контролы
sort: 6
---

# Подготовка
В рамках SDK интерактивы являются контейнерами. У каждого контейнера есть свой набор свойств и контролов. В SDK 
предусмотрена возможность добавления таких контейнеров. Перед началом следует ознакомиться с описанием структур данных
в разделе [Структура данных](data-structure-ru.md).

## Описание пользовательского контейнера в manifest.json
После ознакомления с используемыми структурами данных, следует определиться, как будет описываться ваш
пользовательский контейнер и, возможно, пользовательские контролы (допускается использование готовых контролов, которые 
поставляются вместе с SDK). Подробнее о создании контролов расписано далее.  
При определении описания пользовательского контейнера необходимо задать своё уникальное значение поля **type**. 
Опционально придумать свою структуру объекта **props**, в котором можно задавать специфичные параметры для вашего 
контейнера. Если вы планируете использовать пользовательские контролы, то необходимо проделать те же самые действия и с 
ними.

Пример (стандартные поля опущены):

    {
        ...
        "type": "YOUR_CONTAINER_TYPE",
        "props": {
            ...
            "someCustomProps": 42,
            ...
        },
        "controls":[
            {
                ...
                "type": "YOUR_CONTROL_TYPE",
                "props": {
                    ...
                    "yetAnotherCustomProps": "word"
                    ...
                },
                ...
            }
        ],
        ...
    }

# Фабрика пользовательских контейнеров

Добавление пользовательских контейнеров с помощью фабрик актуален, если 
используется **SimpleInteractivePlayer**, либо стандартная реализация _EventController_ 
**DefaultEventController**.  
**SimpleInteractivePlayer** и **DefaultEventController** реализуют интерфейс **ContainerFactoryProvider**.
Через методы данного интерфейса происходит добавление фабрик.

## ContainerFactoryProvider
Методы **ContainerFactoryProvider**:  
    
    /** Добавление фабрики */
    fun addContainerFactory(item: FactoryItem)

    /** Удаление фабрики */
    fun removeContainerFactory(item: FactoryItem): Boolean

    /** Получить список всех фабрик */
    fun getAllContainerFactories(): List<FactoryItem>
    
    /** Удалить все фабрики */
    fun removeAllContainerFactories()

**Важно!**  
**SimpleInteractivePlayer** и **DefaultEventController** уже 
содержат фабрику по умолчанию для создания стандартных контейнеров. При вызове _removeAllContainerFactories_ 
эта фабрика будет удалена. Этот метод стоит вызвать, если не планируется использовать
стандартные контейнеры, либо необходимо предоставить пользовательскую реализацию стандартных контейнеров.

### FactoryItem
**ContainerFactoryProvider** оперирует объектами **FactoryItem**  
Структура класса **FactoryItem**:

    data class FactoryItem(
        val factory: ContainerFactory, 
        val priority: Float = 1f
    )

- _factory_ - фабрика контейнеров
- _priority_ - приоритет фабрики. Может быть любым значением с плавающей запятой.
При создании контейнера происходит перебор фабрик от большего к меньшему. Остановка 
происходит тогда, когда одна из фабрик смогла создать контейнер с заданным типом

## ContainerFactory
Интерфейс для создания контейнера.  
Описание интерфейса:  

    interface ContainerFactory {
        fun create(data: ContainerData, callback: EventCallback): ControlContainer?
    }

Интерфейс содержит всего один метод create. Данный метод создает экземпляр класса **ControlContainer**, 
необходимый для отображения контейнера на экране. Если реализация интерфейса не может
создать контейнер, основываясь на переданных данных, то следует вернуть _null_.  
Для создания контейнера передаются два параметра.  
- **ContainerData** - данные, необходимые для создания контейнера.
- **EventCallback** - интерфейс для взаимодействия с логикой интерактивного плеера.

Возвращаемое значение является экземпляром класса, унаследованного от 
абстрактного класса ControlContainer. Данный класс отвечает за логику и отображение
контейнера. Абстрактный класс ControlContainer будет рассмотрен далее.

### ContainerData
Класс ContainerData содержит в себе данные, необходимые для создания контейнера.

Описание класса:

    data class ContainerData(
        val container: Container,
        val currentTime: Long,
        val history: History?,
        val state: Parcelable? = null
    )

- _container_ - информация о контейнере, которая была получена из манифеста
- _currentTime_ - Текущее время проигрываемой главы в миллисекундах
- _history_ - история прохождения. Иными словами, запись действий пользователя
- _state_ - сохраненное состояние. Необходимо для реализации восстановления состояния
после смены конфигурации.

Структура класса **Container** рассмотрена в разделе [Структура данных](data-structure-ru.md)

### EventCallback
Интерфейс для взаимодействия с логикой интерактивного плеера.

Описание интерфейса:

    fun interface EventCallback {
        fun onEvent(eventInvocation: EventInvocation)
    }

Если контейнеру необходимо оповестить логику интерактивного плеера о том,
что произошло какое-то событие (пользователь нажал кнопку и т.п.), то контейнеру
необходимо вызвать метод _onEvent_ передав объект **EventInvocation**, который описывает произошедшее событие

#### EventInvocation
Класс EventInvocation описывает произошедшее событие

Описание класса EventInvocation:

    class EventInvocation(
        /** Контейнер, который отослал данное событие */
        val container: Container,
        val event: Event,

        /** Опциональное поле. Контрол, который стал причиной события */
        val blame: Control?
    )

Структуры классов **Event** и **Control** рассмотрены в разделе [Структура данных](data-structure-ru.md)

## ControlContainer
Для реализации логики и отображения контейнера, необходимо создать собственный класс, 
унаследовавшись от абстрактного класса ControlContainer

### Доступные поля ControlContainer
- ```val isAttached: Boolean``` - равняется true, если контейнер прикреплен к экрану (отображается на экране)
- ```val isDetached: Boolean``` - равняется true, если контейнер **был** откреплен от экрана
- ```protected val isPaused: Boolean``` - равняется true, если воспроизведение находится на паузе
- ```protected val lastPlaybackState: PlaybackStateListener.PlaybackState``` - хранит последнее известное состояние 
плеера
- ```open var autoRemoveView: Boolean = true``` - означает, удалять ли автоматически отображение при вызове метода 
detach() (открепить) логикой плеера. Если выставить значение false, то 
необходимо самим позаботиться об удалении View с экрана. Для этого необходимо вызвать метод removeView(). **Важно!**  При 
значении false не гарантировано, что View не будет удалена принудительно игровой логикой в особых ситуациях.

### Доступные методы ControlContainer
- ```open fun getView(): View?``` - возвращает экземпляр класса View, либо его наследника, либо null. Иными словами, 
возвращается визуальное представление, которое будет помещено на экран. При унаследовании от класса ControlContainer, 
необходимо переопределить данный метод для возможности отображения данного контейнера на экране
- ```open getState(): Parcelable?``` - данный метод необходим для возможности сохранения состояния контейнера
при смене конфигурации или уничтожения Activity. При необходимости сохранения состояния 
можно переопределить данный метод, затем, как один из возможных вариантов, в конструкторе класса, унаследованного 
от ControlContainer, добавить параметр с типом Parcelable и передавать сохраненное состояние из вашей фабрики 
контейнеров (из класса ContainerData) в унаследованный от ControlContainer класс через конструктор
- ```fun onAttach()``` - вызывается после размещения контейнера на экране
- ```fun onPlay(time: Long)``` - вызывается, когда плеер переходит в состояние воспроизведения
- ```fun onPause(time: Long)``` - вызывается, когда плеер переходит в состояние паузы
- ```fun onDestroy()``` - вызывается при уничтожении интерактивного плеера
- ```fun onDetach()``` - вызывается при откреплении (исчезновении) контейнера с экрана
- ```protected fun runOnUi(task: () -> Unit)``` - вспомогательный метод, для возможности вызова действий в UI потоке
- ```fun removeView()``` - метод для ручного удаления отображения контейнера с экрана

# Рекомендации
Система внедрения пользовательских контейнеров достаточно гибкая. Есть возможность реализовывать отображение и 
расположение элементов по своему усмотрению, игнорируя Layout и список Control в объекте Container, но рекомендуется следовать 
принятым в SDK best practices.

1. Не пренебрегайте указанным списком Control в Container. Используйте Control для создания ControlView, ориентируясь на 
поле **type**. Если вам достаточно стандартных реализаций ControlView, то вы можете воспользоваться специальной фабрикой 
для их создания **DefaultControlViewFactory**. Следующий пункт в списке позволит понять, как их размещать на экране. 
Более подробно про **ControlView** описано далее. 
2. Не пренебрегайте указанным Layout в Container. Более подробно про Layout можно почитать в разделе 
[Структура данных](data-structure-ru.md). Если вам достаточно типов Layout, что идут в комплекте с SDK, то вы можете 
воспользоваться стандартной фабрикой **DefaultControlLayout**, которая позволяет создавать экземпляры ControlLayout. 
ControlLayout необходим для расположения ControlView, которые были затронуты ранее. Возвращать полученный вызовом метода getView у ControlLayout View рекомендуется в методе getView вашей реализации ControlContainer.

Описание интерфейса ControlLayout:

    interface ControlLayout {
        fun getView(): View
    
        fun add(controlView: ControlView, layoutParams: LayoutParams?)
    
        fun add(controlViews: List<Pair<ControlView, LayoutParams?>>) {
            controlViews.forEach { add(it.first, it.second) }
        }
    }

## ControlView
ControlView по смыслу, является составным элементом ControlContainer. ControlContainer решает, как внутри расположить
ControlView.

Описание интерфейса ControlView:

    interface ControlView {
        fun getView(): View
        fun setEventCallback(callback: ControlEventCallback)
    }

- ```fun getView(): View``` - возвращает отображение
- ```fun setEventCallback(callback: ControlEventCallback)``` - устанавливает колбек для передачи событий над ControlView

Описание ControlEventCallback:

    fun interface ControlEventCallback {
        fun onEvent(event: Event)
    }